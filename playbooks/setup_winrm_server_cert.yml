- name: Setup WinRM HTTPS listener with CA-signed server certificate (refactored)
  hosts: windows
  gather_facts: false

  tasks:

    - name: Check for existing WinRM server certificate on Windows (thumbprint)
      ansible.windows.win_shell: |
        try {
          $hostname = "{{ ansible_host }}"
          $cert = Get-ChildItem Cert:\LocalMachine\My |
                Where-Object {
                  ($_.EnhancedKeyUsageList.FriendlyName -contains "Server Authentication") -and
                  ( ($_.Subject -like "*CN=$hostname*") -or ($_.Subject -like "*$hostname*") -or ($_.Subject -like "*{{ inventory_hostname }}*") )
                } |
                Select-Object -First 1
          if ($cert) {
              Write-Output $cert.Thumbprint
          } else {
              Write-Output ""
          }
        } catch {
            Write-Output ""
        }
      register: server_cert_thumbprint
      failed_when: false
      changed_when: false

    - name: Debug - Existing server cert thumbprint
      ansible.builtin.debug:
        msg: "Existing server cert thumbprint: {{ server_cert_thumbprint.stdout | default('No Found') }}"

    - name: Ensure cert directory exists on control node
      delegate_to: localhost
      ansible.builtin.file:
        path: "{{ cert_dir }}"
        state: directory
        mode: '0755'

    - name: Ensure C:\Temp exists on Windows Host
      ansible.windows.win_file:
        path: C:\Temp
        state: directory

    - name: Create OpenSSL ext file for serverAuth EKU and SAN (control node)
      delegate_to: localhost
      run_once: true
      ansible.builtin.copy:
        dest: "{{ openssl_ext_path }}"
        content: |
          [ req ]
          distinguished_name = req_distinguished_name
          req_extensions = v3_req
          prompt = no
          [ req_distinguished_name ]
          CN = {{ inventory_hostname }}
          [ v3_req ]
          keyUsage = critical, digitalSignature, keyEncipherment
          extendedKeyUsage = serverAuth
          subjectAltName = @alt_names
          [ alt_names ]
          DNS.1 = {{ ansible_host }}
          DNS.2 = {{ inventory_hostname }}
        mode: '0644'
      changed_when: false

    - name: Register Variable - server key (control node)
      delegate_to: localhost
      ansible.builtin.stat:
        path: "{{ server_key_path }}"
      register: stat_server_key

    - name: Register Variable - server csr (control node)
      delegate_to: localhost
      ansible.builtin.stat:
        path: "{{ server_csr_path }}"
      register: stat_server_csr

    - name: Generate server private key and CSR on control node (if missing)
      delegate_to: localhost
      run_once: true
      ansible.builtin.shell: |
        set -e
        openssl genrsa -out "{{ server_key_path }}" 2048
        openssl req -new -key "{{ server_key_path }}" \
          -out "{{ server_csr_path }}" \
          -config "{{ openssl_ext_path }}"
      args:
        executable: /bin/bash
      when: not (stat_server_key.stat.exists and stat_server_csr.stat.exists)
      register: gen_csr_result
      changed_when: gen_csr_result.rc == 0

    - name: Register Variable - server crt (control node)
      delegate_to: localhost
      ansible.builtin.stat:
        path: "{{ server_crt_path }}"
      register: stat_server_crt

    - name: Sign CSR with CA to produce server certificate (control node) (if missing)
      delegate_to: localhost
      run_once: true
      ansible.builtin.shell: |
        set -e
        # Sign CSR with CA cert/key and include v3 extensions
        openssl x509 -req -in "{{ server_csr_path }}" \
          -CA "{{ ca_cert_path }}" \
          -CAkey "{{ ca_key_path }}" \
          -CAcreateserial \
          -out "{{ server_crt_path }}" \
          -days {{ server_cert_days }} \
          -extensions v3_req -extfile "{{ openssl_ext_path }}"
      args:
        executable: /bin/bash
      when: not stat_server_crt.stat.exists
      register: sign_crt_result
      changed_when: sign_crt_result.rc == 0

    - name: Check if PFX already exists (control node)
      delegate_to: localhost
      ansible.builtin.stat:
        path: "{{ server_pfx_path }}"
      register: server_pfx_stat

    - name: Create PFX from server key+crt+CA (control node) (if missing)
      delegate_to: localhost
      run_once: true
      ansible.builtin.shell: |
        set -e
        if [ -z "{{ certificate_password }}" ]; then
          openssl pkcs12 -export \
            -out "{{ server_pfx_path }}" \
            -inkey "{{ server_key_path }}" \
            -in "{{ server_crt_path }}" \
            -certfile "{{ ca_cert_path }}" \
            -passout pass:
        else
          openssl pkcs12 -export \
            -out "{{ server_pfx_path }}" \
            -inkey "{{ server_key_path }}" \
            -in "{{ server_crt_path }}" \
            -certfile "{{ ca_cert_path }}" \
            -passout pass:{{ certificate_password }}
        fi
      args:
        executable: /bin/bash
      when: not server_pfx_stat.stat.exists
      register: make_pfx_result
      changed_when: make_pfx_result.rc == 0

    # -------------------------------------
    # Copy Certs to Windows endpoints
    # -------------------------------------

    - name: Check if PFX exists on Windows Host
      ansible.windows.win_stat:
        path: "C:\\Temp\\winrm_server.pfx"
      register: winrm_pfx_stat

    - name: Copy PFX to Windows host if server certificate absent on host
      ansible.windows.win_copy:
        src: "{{ server_pfx_path }}"
        dest: "C:\\Temp\\winrm_server.pfx"
      when: not winrm_pfx_stat.stat.exists and server_pfx_stat.stat.exists

    - name: Import PFX into LocalMachine\\My store (Windows) if cert missing
      ansible.windows.win_shell: |
        $pfxPath = "C:\Temp\winrm_server.pfx"
        $password = ConvertTo-SecureString -String "{{ certificate_password }}" -Force -AsPlainText
        Import-PfxCertificate -FilePath $pfxPath \
          -CertStoreLocation Cert:\LocalMachine\My -Password $password | Out-Null
      when: winrm_pfx_stat.stat.exists and server_pfx_stat.stat.exists
      register: import_pfx
      changed_when: import_pfx.rc == 0

    # ------------------------------------------------
    # Check imported Certificates on Windows endpoints
    # ------------------------------------------------

    - name: Get List of certificates in LocalMachine\My
      ansible.windows.win_certificate_info:
        store_name: My
        store_location: LocalMachine
      register: cert_info

    - name: Filter certificates to only those with Server Authentication EKU
      ansible.builtin.set_fact:
        server_cert_with_eku: >-
          {{ cert_info.certificates
            | selectattr('enhanced_key_usage', 'defined')
            | selectattr('enhanced_key_usage', 'contains', 'Server Authentication')
            | selectattr('dns_names', 'contains', ansible_host)
            | list }}

    - name: Create WinRM HTTPS listener if Server Auth cert exists
      ansible.windows.win_shell: |
        $thumbprint = "{{ server_cert_with_eku[0].thumbprint }}"
        $hostname = "{{ ansible_host }}"
        $listener = winrm enumerate winrm/config/listener |
                Where-Object { $_.Transport -eq 'HTTPS' }
        if (-not $listener) {
            winrm create winrm/config/Listener?Address=*+Transport=HTTPS @{
                Hostname = $hostname;
                CertificateThumbprint = $thumbprint
            }
        } else {
            Write-Host "HTTPS WinRM listener already exists."
        }
      when:
        - server_cert_with_eku is defined
        - server_cert_with_eku.thumbprint is defined
        - server_cert_with_eku.thumbprint | length > 0
      register: winrm_listener
      failed_when:
        - winrm_listener.rc != 0
        - "'already exists' not in (winrm_listener.stdout | default('') + winrm_listener.stderr | default(''))"

    - name: Open firewall for WinRM HTTPS (Windows)
      ansible.windows.win_firewall:
        name: "WinRM HTTPS"
        enable: true
        localport: 5986
        protocol: TCP
        direction: in
        action: allow
      when:
        - server_cert_with_eku is defined
        - server_cert_with_eku.thumbprint is defined
        - server_cert_with_eku.thumbprint | length > 0

    - name: Optional - cleanup temporary ext file on control node (leave false by default)
      delegate_to: localhost
      ansible.builtin.file:
        path: "{{ openssl_ext_path }}"
        state: absent
      when: false
